struct Cryptography {
  sendiv : Bytes
  recviv : Bytes
}

pub fn Cryptography::from_handshake(handshake : Bytes) -> Cryptography {
  let sendiv = FixedArray::makei(header_length, fn(i) { handshake[i + 7] })
    |> @bytes.of
  let recviv = FixedArray::makei(header_length, fn(i) { handshake[i + 11] })
    |> @bytes.of
  Cryptography::new(sendiv, recviv)
}

pub fn Cryptography::new(sendiv : Bytes, recviv : Bytes) -> Cryptography {
  { sendiv, recviv }
}

pub fn check_length(self : Cryptography, bytes : Bytes) -> Int {
  let headermask : UInt = (0).until(4).fold(
    fn(headermask, i) { headermask | (bytes[i].to_int().to_uint() << (8 * i)) },
    init=0,
  )
  (headermask.lsr(16) ^ (headermask & 0xFFFF)).to_int()
}

let mapleversion = 83

fn create_header(self : Cryptography, buffer : Bytes, length : Int) -> Unit {
  let a = ((self.sendiv[3].to_int() << 8) | self.sendiv[2].to_int()) ^ mapleversion
  let b = a ^ length
  // iv2^mapleversion0
  buffer[0] = (a & 0xFF).to_byte()
  // iv3^mapleversion1
  buffer[1] = (a >> 8).to_byte()
  // iv2^mapleversion0^len0
  buffer[2] = (b & 0xFF).to_byte()
  // iv3^mapleversion1^len1 
  buffer[3] = (b >> 8).to_byte()
}

pub fn encrypt(self : Cryptography, bytes : Bytes) -> Unit {
  mapleencrypt(bytes)
  aesofb(bytes, self.sendiv)
}

fn mapleencrypt(bytes : Bytes) -> Unit {
  let length = bytes.length()
  for j = 0; j < 3; j = j + 1 {
    let mut remember = 0
    let mut datalen = length & 0xFF
    for i = 0; i < length; i = i + 1 {
      let mut cur = (rollleft(bytes[i], 3).to_int() + datalen) ^ remember
      remember = cur
      cur = rollright(cur.to_byte(), datalen & 0xFF).to_int()
      bytes[i] = ((cur.lnot() & 0xFF) + 0x48).to_byte()
      datalen = datalen - 1
    }
    remember = 0
    datalen = length & 0xFF
    for i = length - 1; i >= 0; i = i - 1 {
      let cur = (rollleft(bytes[i], 4).to_int() + datalen) ^ remember
      remember = cur
      bytes[i] = rollright((cur ^ 0x13).to_byte(), 3)
      datalen -= 1
    }
  }
}

pub fn decrypt(self : Cryptography, bytes : Bytes) -> Unit {
  aesofb(bytes, self.recviv)
  mapledecrypt(bytes)
}

fn mapledecrypt(bytes : Bytes) -> Unit {
  let length = bytes.length()
  (0).until(3).each(
    fn(i) {
      let mut remember = 0
      let mut datalen = length & 0xFF
      length.until(-1, step=-1).each(
        fn(j) {
          let cur = rollleft(bytes[j], 3).to_int() ^ 0x13
          bytes[j] = rollright(((cur ^ remember) - datalen).to_byte(), 4)
          remember = cur
          datalen -= 1
        },
      )
      remember = 0
      datalen = length & 0xFF
      (0).until(length).each(
        fn(j) {
          let b : Byte = bytes[i]
          let mut cur = (b.to_int() - 0x48).lnot() & 0xFF
          cur = rollleft(cur.to_byte(), datalen & 0xFF).to_int()
          bytes[j] = rollright(((cur ^ remember) - datalen).to_byte(), 3)
          remember = cur
          datalen -= 1
        },
      )
    },
  )
}

fn rollleft(data : Byte, count : Int) -> Byte {
  let mask = (data.to_int() & 0xFF) << (count % 8)
  return ((mask & 0xFF) | (mask >> 8)).to_byte()
}

fn rollright(data : Byte, count : Int) -> Byte {
  let mask = (data.to_int() & 0xFF) << (count % 8)
  return ((mask & 0xFF) | (mask >> 8)).to_byte()
}

fn aesofb(bytes : Bytes, iv : Bytes) -> Unit {
  let mut blocklength = 0x5B0
  let mut offset = 0
  let length = bytes.length()
  while offset < length {
    let miv = Bytes::new(16)
    for i = 0; i < 16; i = i + 1 {
      miv[i] = iv[i % 4]
    }
    let mut remaining = length - offset
    if remaining > blocklength {
      remaining = blocklength
    }
    for x = 0; x < remaining; x = x + 1 {
      let relpos = x % 16
      if relpos == 0 {
        aesencrypt(miv)
      }
      bytes[x + offset] = (bytes[x + offset].to_int() ^ miv[relpos].to_int()).to_byte()
    }
    offset += blocklength
    blocklength = 0x5B4
  }
  updateiv(iv)
}

let maplebytes : FixedArray[Int] = [
  0xEC, 0x3F, 0x77, 0xA4, 0x45, 0xD0, 0x71, 0xBF, 0xB7, 0x98, 0x20, 0xFC, 0x4B, 0xE9,
  0xB3, 0xE1, 0x5C, 0x22, 0xF7, 0x0C, 0x44, 0x1B, 0x81, 0xBD, 0x63, 0x8D, 0xD4, 0xC3,
  0xF2, 0x10, 0x19, 0xE0, 0xFB, 0xA1, 0x6E, 0x66, 0xEA, 0xAE, 0xD6, 0xCE, 0x06, 0x18,
  0x4E, 0xEB, 0x78, 0x95, 0xDB, 0xBA, 0xB6, 0x42, 0x7A, 0x2A, 0x83, 0x0B, 0x54, 0x67,
  0x6D, 0xE8, 0x65, 0xE7, 0x2F, 0x07, 0xF3, 0xAA, 0x27, 0x7B, 0x85, 0xB0, 0x26, 0xFD,
  0x8B, 0xA9, 0xFA, 0xBE, 0xA8, 0xD7, 0xCB, 0xCC, 0x92, 0xDA, 0xF9, 0x93, 0x60, 0x2D,
  0xDD, 0xD2, 0xA2, 0x9B, 0x39, 0x5F, 0x82, 0x21, 0x4C, 0x69, 0xF8, 0x31, 0x87, 0xEE,
  0x8E, 0xAD, 0x8C, 0x6A, 0xBC, 0xB5, 0x6B, 0x59, 0x13, 0xF1, 0x04, 0x00, 0xF6, 0x5A,
  0x35, 0x79, 0x48, 0x8F, 0x15, 0xCD, 0x97, 0x57, 0x12, 0x3E, 0x37, 0xFF, 0x9D, 0x4F,
  0x51, 0xF5, 0xA3, 0x70, 0xBB, 0x14, 0x75, 0xC2, 0xB8, 0x72, 0xC0, 0xED, 0x7D, 0x68,
  0xC9, 0x2E, 0x0D, 0x62, 0x46, 0x17, 0x11, 0x4D, 0x6C, 0xC4, 0x7E, 0x53, 0xC1, 0x25,
  0xC7, 0x9A, 0x1C, 0x88, 0x58, 0x2C, 0x89, 0xDC, 0x02, 0x64, 0x40, 0x01, 0x5D, 0x38,
  0xA5, 0xE2, 0xAF, 0x55, 0xD5, 0xEF, 0x1A, 0x7C, 0xA7, 0x5B, 0xA6, 0x6F, 0x86, 0x9F,
  0x73, 0xE6, 0x0A, 0xDE, 0x2B, 0x99, 0x4A, 0x47, 0x9C, 0xDF, 0x09, 0x76, 0x9E, 0x30,
  0x0E, 0xE4, 0xB2, 0x94, 0xA0, 0x3B, 0x34, 0x1D, 0x28, 0x0F, 0x36, 0xE3, 0x23, 0xB4,
  0x03, 0xD8, 0x90, 0xC8, 0x3C, 0xFE, 0x5E, 0x32, 0x24, 0x50, 0x1F, 0x3A, 0x43, 0x8A,
  0x96, 0x41, 0x74, 0xAC, 0x52, 0x33, 0xF0, 0xD9, 0x29, 0x80, 0xB1, 0x16, 0xD3, 0xAB,
  0x91, 0xB9, 0x84, 0x7F, 0x61, 0x1E, 0xCF, 0xC5, 0xD1, 0x56, 0x3D, 0xCA, 0xF4, 0x05,
  0xC6, 0xE5, 0x08, 0x49,
]

fn updateiv(iv : Bytes) -> Unit {
  let mbytes = [0xF2, 0x53, 0x50, 0xC6]
  for i = 0; i < 4; i = i + 1 {
    let ivbyte = iv[i].to_int()
    mbytes[0] += maplebytes[mbytes[1] & 0xFF] - ivbyte
    mbytes[1] -= (mbytes[2] ^ maplebytes[ivbyte & 0xFF]) & 0xFF
    mbytes[2] = mbytes[2] ^ (maplebytes[mbytes[3] & 0xFF] + ivbyte)
    mbytes[3] += (maplebytes[ivbyte & 0xFF] & 0xFF) - (mbytes[0] & 0xFF)
    let mut mask = 0
    mask = mask | (mbytes[0] & 0xFF)
    mask = mask | ((mbytes[1] << 8) & 0xFF00)
    mask = mask | ((mbytes[2] << 16) & 0xFF0000)
    mask = mask | ((mbytes[3] << 24) & 0xFF000000)
    mask = (mask >> 0x1D) | (mask << 3)
    for j = 0; j < 4; j = j + 1 {
      let value = mask >> (8 * j)
      mbytes[j] = value & 0xFF
    }
  }
  for i = 0; i < 4; i = i + 1 {
    iv[i] = mbytes[i].to_byte()
  }
}

fn aesencrypt(bytes : Bytes) -> Unit {
  let round = 0
  addroundkey(bytes, round)
  for round = 1; round < 14; round = round + 1 {
    subbytes(bytes)
    shiftrows(bytes)
    mixcolumns(bytes)
    addroundkey(bytes, round)
  }
  subbytes(bytes)
  shiftrows(bytes)
  addroundkey(bytes, round)
}

/// This key is already expanded
/// Only works for versions lower than version 118
let maplekey = [
  0x13, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xB4, 0x00,
  0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
  0x52, 0x00, 0x00, 0x00, 0x71, 0x63, 0x63, 0x00, 0x79, 0x63, 0x63, 0x00, 0x7F, 0x63,
  0x63, 0x00, 0xCB, 0x63, 0x63, 0x00, 0x04, 0xFB, 0xFB, 0x63, 0x0B, 0xFB, 0xFB, 0x63,
  0x38, 0xFB, 0xFB, 0x63, 0x6A, 0xFB, 0xFB, 0x63, 0x7C, 0x6C, 0x98, 0x02, 0x05, 0x0F,
  0xFB, 0x02, 0x7A, 0x6C, 0x98, 0x02, 0xB1, 0x0F, 0xFB, 0x02, 0xCC, 0x8D, 0xF4, 0x14,
  0xC7, 0x76, 0x0F, 0x77, 0xFF, 0x8D, 0xF4, 0x14, 0x95, 0x76, 0x0F, 0x77, 0x40, 0x1A,
  0x6D, 0x28, 0x45, 0x15, 0x96, 0x2A, 0x3F, 0x79, 0x0E, 0x28, 0x8E, 0x76, 0xF5, 0x2A,
  0xD5, 0xB5, 0x12, 0xF1, 0x12, 0xC3, 0x1D, 0x86, 0xED, 0x4E, 0xE9, 0x92, 0x78, 0x38,
  0xE6, 0xE5, 0x4F, 0x94, 0xB4, 0x94, 0x0A, 0x81, 0x22, 0xBE, 0x35, 0xF8, 0x2C, 0x96,
  0xBB, 0x8E, 0xD9, 0xBC, 0x3F, 0xAC, 0x27, 0x94, 0x2D, 0x6F, 0x3A, 0x12, 0xC0, 0x21,
  0xD3, 0x80, 0xB8, 0x19, 0x35, 0x65, 0x8B, 0x02, 0xF9, 0xF8, 0x81, 0x83, 0xDB, 0x46,
  0xB4, 0x7B, 0xF7, 0xD0, 0x0F, 0xF5, 0x2E, 0x6C, 0x49, 0x4A, 0x16, 0xC4, 0x64, 0x25,
  0x2C, 0xD6, 0xA4, 0x04, 0xFF, 0x56, 0x1C, 0x1D, 0xCA, 0x33, 0x0F, 0x76, 0x3A, 0x64,
  0x8E, 0xF5, 0xE1, 0x22, 0x3A, 0x8E, 0x16, 0xF2, 0x35, 0x7B, 0x38, 0x9E, 0xDF, 0x6B,
  0x11, 0xCF, 0xBB, 0x4E, 0x3D, 0x19, 0x1F, 0x4A, 0xC2, 0x4F, 0x03, 0x57, 0x08, 0x7C,
  0x14, 0x46, 0x2A, 0x1F, 0x9A, 0xB3, 0xCB, 0x3D, 0xA0, 0x3D, 0xDD, 0xCF, 0x95, 0x46,
  0xE5, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
]

fn addroundkey(bytes : Bytes, round : Int) -> Unit {
  let offset = round * 16
  for i = 0; i < 16; i = i + 1 {
    bytes[i] = (bytes[i].to_int() ^ maplekey[i + offset]).to_byte()
  }
}

/// Rijndael substitution box
let subbox = [
  0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7,
  0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF,
  0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5,
  0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
  0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,
  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED,
  0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF,
  0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
  0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF,
  0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,
  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE,
  0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
  0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5,
  0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E,
  0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,
  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
  0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55,
  0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F,
  0xB0, 0x54, 0xBB, 0x16,
]

fn subbytes(bytes : Bytes) -> Unit {
  (0).until(16).each(fn(i) { bytes[i] = subbox[bytes[i].to_int()].to_byte() })
}

fn shiftrows(bytes : Bytes) -> Unit {
  let mut remember = bytes[1]
  bytes[1] = bytes[5]
  bytes[5] = bytes[9]
  bytes[9] = bytes[13]
  bytes[13] = remember
  remember = bytes[10]
  bytes[10] = bytes[2]
  bytes[2] = remember
  remember = bytes[3]
  bytes[3] = bytes[15]
  bytes[15] = bytes[11]
  bytes[11] = bytes[7]
  bytes[7] = remember
  remember = bytes[14]
  bytes[14] = bytes[6]
  bytes[6] = remember
}
// uint8_t Cryptography::gmul(uint8_t x) const {
//     return (x << 1) ^ (0x1B & (uint8_t)((int8_t)x >> 7));
// }

// void Cryptography::mixcolumns(uint8_t *bytes) const {
//     for (int i = 0; i < 16; i += 4) {
//         uint8_t cpy0 = bytes[i];
//         uint8_t cpy1 = bytes[i + 1];
//         uint8_t cpy2 = bytes[i + 2];
//         uint8_t cpy3 = bytes[i + 3];

//         uint8_t mul0 = gmul(bytes[i]);
//         uint8_t mul1 = gmul(bytes[i + 1]);
//         uint8_t mul2 = gmul(bytes[i + 2]);
//         uint8_t mul3 = gmul(bytes[i + 3]);

//         bytes[i] = mul0 ^ cpy3 ^ cpy2 ^ mul1 ^ cpy1;
//         bytes[i + 1] = mul1 ^ cpy0 ^ cpy3 ^ mul2 ^ cpy2;
//         bytes[i + 2] = mul2 ^ cpy1 ^ cpy0 ^ mul3 ^ cpy3;
//         bytes[i + 3] = mul3 ^ cpy2 ^ cpy1 ^ mul0 ^ cpy0;
//     }
// }
fn gmul(x : Byte) -> Byte {
  ((x.to_int() << 1) ^ (0x1B & (x.to_int() >> 7))).to_byte()
}

fn mixcolumns(bytes : Bytes) -> Unit {
  (0).until(16, step=4).each(
    fn(i) {
      let cpy0 = bytes[i].to_int()
      let cpy1 = bytes[i + 1].to_int()
      let cpy2 = bytes[i + 2].to_int()
      let cpy3 = bytes[i + 3].to_int()
      let mul0 = gmul(bytes[i]).to_int()
      let mul1 = gmul(bytes[i + 1]).to_int()
      let mul2 = gmul(bytes[i + 2]).to_int()
      let mul3 = gmul(bytes[i + 3]).to_int()
      bytes[i] = (mul0 ^ cpy3 ^ cpy2 ^ mul1 ^ cpy1).to_byte()
      bytes[i + 1] = (mul1 ^ cpy0 ^ cpy3 ^ mul2 ^ cpy2).to_byte()
      bytes[i + 2] = (mul2 ^ cpy1 ^ cpy0 ^ mul3 ^ cpy3).to_byte()
      bytes[i + 3] = (mul3 ^ cpy2 ^ cpy1 ^ mul0 ^ cpy0).to_byte()
    },
  )
}
